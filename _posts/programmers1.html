<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    문제 설명
    어떤 나라에 총 N개의 도시가 있으며, 각 도시에는 1번부터 N 번까지 번호가 붙어있습니다. 이 나라를 방문한 여행자들은 도시 간에 연결된 열차를 이용해서 이동합니다. 이 나라의 열차는 두 회사 A, B에서 운영을 맡고 있으며, 모든 열차는 양방향 통행이 가능합니다. 여행자들은 적절한 열차를 선택해서 도시 간에 이동할 수 있으며, 임의의 두 도시 간에는 항상 열차를 이용해서 이동할 수 있는 경로가 존재합니다.
    이 나라를 방문한 여행자가 S 번 도시에서 출발하여 E 번 도시로 이동하려고 합니다. 이 여행자는 S 번 도시에서 E 번 도시로 가기 위해 필요한 최소 시간을 계산하려고 합니다. 여행자는 각 도시에서 다른 도시로 이동하기 위해 A사 혹은 B사의 열차를 이용할 수 있습니다. 이때, A사의 열차에서 B사의 열차로, 혹은 B사의 열차에서 A사의 열차로 갈아타기 위해서는 환승 게이트를 통과해야 합니다. 도시별로 환승 게이트를 통과하는데 일정한 시간이 소요되며, 같은 회사의 열차를 이용해서 도시에 도착하고 출발할 때는 환승 게이트를 이용하지 않아도 괜찮습니다. 예를 들어 어떤 도시에 A사의 열차를 이용해서 도착했을 경우, 다시 A사의 열차를 이용해서 다른 도시로 이동한다면 환승 게이트를 통과하지 않아도 되지만, 만약 B사의 열차를 이용해서 다른 도시로 이동하고자 한다면 반드시 환승 게이트를 통과해야 하며, 반대의 경우에도 마찬가지입니다. 단, 맨 처음 출발하는 도시에서는 A사 열차 탑승장, 혹은 B사 열차 탑승장 어느 쪽에서든 바로 출발이 가능합니다.(즉, 처음 시작 위치에서는 환승 게이트 통과에 걸리는 시간을 고려하지 않습니다)
    다음은 N = 4일 때, A사와 B사의 열차 운행 정보를 나타낸 예시입니다.
    
    image
    
    위 그림에서 각 정점에 적힌 숫자는 도시의 번호를, 각 정점에 적힌 파란색 숫자는 환승에 걸리는 시간을, 붉은색 간선은 A사의 열차 운행을, 검은색 간선은 B사의 열차 운행을 나타냅니다.
    1번 도시에서 출발한 여행자가 3번 도시까지 이동하는데 걸리는 가장 짧은 시간은 1번 도시와 3번 도시를 연결하는 A사의 열차를 이용했을 때 3의 시간이 걸립니다. 이때, 1번 도시에서 4번 도시까지 이동하기 위해서 3번 도시까지 3의 시간에 A사의 열차를 타고 왔다면, B사의 열차로 환승하기 위하여 2의 시간이 추가로 소모되며, 따라서 4번 도시까지 이동하는데 6의 시간이 소요됩니다. 그러나 만약 1번 도시에서 2번 도시로 A사의 열차, 2번 도시에서 3번 도시까지 B사의 열차, 3번 도시에서 4번 도시까지 B사의 열차를 이용한다면 2번 도시에서의 환승 시간 1을 더해 총 이동시간이 1 + 1 + 2 + 1 = 5로 최단시간 5에 4번 도시로 이동할 수 있습니다.
    
    전체 도시의 개수 N과 각 도시에서 환승에 걸리는 시간이 순서대로 들어있는 배열 transfer, A사의 열차 운행 정보가 들어있는 배열 trainA, B사의 열차 운행 정보가 들어있는 배열 trainB, 여행자가 출발하는 도시 s, 도착하는 도시 e가 매개변수로 주어질 때, s번 도시에서 출발한 여행자가 e번 도시에 도착하는데 걸리는 최소 시간을 return하도록 solution함수를 완성해주세요.
    
    제한사항
    N은 2 이상 50,000 이하의 자연수입니다.
    transfer는 1번 도시부터 N번 도시까지의 환승 시간이 순서대로 들어있는 배열이며, 각 도시의 환승 시간은 1 이상 100,000이하의 정수입니다.
    trainA, trainB는 두 열차 회사 A, B의 열차 정보가 들어있는 배열이며, 각 회사의 열차 정보의 개수(trainA, trainB의 길이)는 1이상 100,000이하입니다.
    trainA, trainB의 각 배열의 원소는 열차 정보 [u, v, w]를 나타냅니다.
    u 와 v는 열차가 연결하는 두 도시의 번호입니다.( 1 ≤ u, v ≤ N, u ≠ v)
    w(1 ≤ w ≤ 100,000)는 열차가 두 도시사이를 이동하는데 걸리는 시간입니다.
    각 회사별로 동일한 도시 쌍에 대한 열차정보는 최대 한번만 주어집니다. 즉, 각 회사는 도시와 도시사이에 한개씩의 열차만 운행합니다.
    s는 여행자가 출발하는 도시의 번호, e는 여행자가 도착하고자 하는 도시의 번호입니다(1 ≤ s, e ≤ N, s ≠ e)
    s번 도시에서 출발한 여행자가 e번 도시에 도착하는데 걸리는 최소 시간을 return하세요.
    입출력 예
    N	transfer	trainA	trainB	s	e	result
    4	[1,1,2,3]	[[1,2,1],[1,3,3],[2,3,3]]	[[1,2,3],[2,3,2],[3,4,1]]	1	4	5
    4	[1,1,2,3]	[[1,2,1],[1,3,3],[2,3,3]]	[[1,2,3],[2,3,2],[3,4,1]]	2	1	1
    4	[1,1,2,3]	[[1,2,1],[1,3,3],[2,3,3]]	[[1,2,3],[2,3,2],[3,4,1]]	2	3	2
    입출력 예 설명
    입출력 예 #1
    문제의 예시와 같습니다.
    
    입출력 예 #2
    주어진 입력의 그림은 문제의 예시와 같습니다.
    출발 위치에서는 환승에 필요한 시간을 고려하지 않습니다. 따라서 2번 도시에서 1번 도시로 가기 위한 최소 시간은 A사의 열차를 이용해서 1의 시간에 바로 갈 수 있습니다.
    
    입출력 예 #3
    주어진 입력의 그림은 문제의 예시와 같습니다.
    출발 위치에서는 환승에 필요한 시간을 고려하지 않습니다. 따라서 2번 도시에서 3번 도시로 가기 위한 최소 시간은 B사의 열차를 이용해서 2의 시간에 바로 갈 수 있습니다. 
</body>
<script>


    const solution = (P =[]) => {
        let problems = P;
        let result = 0;

        while(problems.length > 0 ) {
            const filtered = problems.filter((value, index) => !(problems.indexOf(value) === index))
            result += problems.length - filtered.length -1 
            problems = filtered;
        }
        return result
    }
    
</script>
</html>